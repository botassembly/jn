#!/bin/bash
#
# todo - A feature-rich todo CLI powered by jn
#
# BEADS-inspired features: blockers, ready work, dependency trees, subtasks
#
# Usage:
#   todo add "Buy groceries"           Add a new todo
#   todo add -p high "Urgent task"     Add with priority (high/med/low)
#   todo add -d 2024-12-25 "Gift"      Add with due date
#   todo add --parent 1 "Subtask"      Add as subtask of #1
#   todo list                          List all todos
#   todo done <id>                     Mark todo as complete
#   todo skip <id>                     Mark todo as skipped
#   todo reopen <id>                   Reopen a done/skipped todo
#   todo edit <id> "New text"          Edit todo text
#   todo rm <id>                       Remove a todo
#   todo clear                         Remove all completed/skipped todos
#   todo count                         Show counts by status
#   todo search <term>                 Search todos by text
#   todo note <id> "Note text"         Add a note to a todo
#   todo tag <id>                      Show tags on a todo
#   todo list @work                    Filter by @mention tag
#   todo list #urgent                  Filter by #hashtag
#   todo due                           Show overdue and upcoming todos
#   todo export [md|csv]               Export todos to markdown or CSV
#   todo undo                          Undo last destructive operation
#
# BEADS-inspired:
#   todo blocks <a> <b>                Task A blocks task B
#   todo unblock <a> <b>               Remove blocker
#   todo ready                         Show tasks with no blockers
#   todo blocked                       Show tasks waiting on others
#   todo tree [id]                     Show dependency tree
#   todo stats                         Dashboard with statistics
#   todo bump <id>                     Cycle priority: lowâ†’medâ†’highâ†’low
#   todo retag <old> <new>             Rename tag across all todos
#
# Data is stored in .todo.jsonl in the current directory.
# Schema: {"id":"xid...","text":"...","status":"pending","priority":"med",
#          "due":"2024-12-25","tags":[],"notes":[],"blockers":[],"parent":null}
# IDs are XIDs (20-char base32, time-sortable) - use partial prefixes like "cuvs4"
#
# Dependencies: jn-edit, zq (from the jn toolkit)
#

set -e

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

TODO_FILE=".todo.jsonl"
BACKUP_FILE=".todo.jsonl.bak"
QUIET=false

# Event emission - all status messages are JSONL to stderr
# Data output (records) goes to stdout as NDJSON
emit() {
    if [[ "$QUIET" != "true" ]]; then
        echo "$1" >&2
    fi
}

emit_ok() {
    local event="$1"
    shift
    local json="{\"event\":\"$event\",\"status\":\"ok\""
    while [[ $# -gt 0 ]]; do
        json="$json,$1"
        shift
    done
    json="$json}"
    emit "$json"
}

emit_error() {
    local code="$1"
    local message="$2"
    # Errors are always emitted, even in quiet mode
    echo "{\"event\":\"error\",\"status\":\"error\",\"code\":\"$code\",\"message\":\"$message\"}" >&2
}

# -----------------------------------------------------------------------------
# Setup: Find jn tools
# -----------------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if command -v jn-edit &> /dev/null && command -v zq &> /dev/null; then
    JN_EDIT="jn-edit"
    ZQ="zq"
else
    # Try libexec layout: jn_home/tools/todo -> ../../ -> libexec/jn/
    LIBEXEC_DIR="$SCRIPT_DIR/../.."
    if [[ -x "$LIBEXEC_DIR/jn-edit" ]] && [[ -x "$LIBEXEC_DIR/zq" ]]; then
        JN_EDIT="$LIBEXEC_DIR/jn-edit"
        ZQ="$LIBEXEC_DIR/zq"
    # Try relative path from demos directory (development layout)
    elif [[ -d "$SCRIPT_DIR/../../tools/zig" ]]; then
        TOOLS_DIR="$SCRIPT_DIR/../../tools/zig"
        ZQ_DIR="$SCRIPT_DIR/../../zq/zig-out/bin"
        export PATH="$ZQ_DIR:$TOOLS_DIR/jn-edit/bin:$PATH"
        JN_EDIT="jn-edit"
        ZQ="zq"
    else
        emit_error "TOOLS_NOT_FOUND" "jn tools not found. Please install jn or run 'make build'."
        exit 1
    fi
fi

# Verify tools exist (check if executable, works for both PATH and full paths)
if [[ ! -x "$JN_EDIT" ]] && ! command -v "$JN_EDIT" &> /dev/null; then
    emit_error "JN_EDIT_NOT_FOUND" "jn-edit not found at $JN_EDIT"
    exit 1
fi
if [[ ! -x "$ZQ" ]] && ! command -v "$ZQ" &> /dev/null; then
    emit_error "ZQ_NOT_FOUND" "zq not found at $ZQ"
    exit 1
fi

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

# Generate a new XID (replaces integer IDs - git-merge friendly)
new_xid() {
    echo '{}' | $ZQ -r 'xid'
}

# Resolve partial ID to full XID (allows short prefix like "0qa0d")
resolve_id() {
    local partial="$1"
    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        echo ""
        return
    fi
    # Find ID that starts with the partial
    local match
    match=$($ZQ -r "select(.id | startswith(\"$partial\")) | .id" < "$TODO_FILE" 2>/dev/null | head -1)
    echo "$match"
}

# Short display ID (first 8 chars of XID)
short_id() {
    local id="$1"
    echo "${id:0:8}"
}

# Create backup before destructive operations
backup() {
    if [[ -f "$TODO_FILE" ]]; then
        cp "$TODO_FILE" "$BACKUP_FILE"
    fi
}


# Check if a date is overdue
is_overdue() {
    local due="$1"
    if [[ -z "$due" ]] || [[ "$due" == "null" ]]; then
        return 1
    fi
    local today
    today=$(date +%Y-%m-%d)
    [[ "$due" < "$today" ]]
}

# Check if due within N days
is_due_soon() {
    local due="$1"
    local days="${2:-3}"
    if [[ -z "$due" ]] || [[ "$due" == "null" ]]; then
        return 1
    fi
    local today future
    today=$(date +%Y-%m-%d)
    future=$(date -d "+${days} days" +%Y-%m-%d 2>/dev/null || date -v+${days}d +%Y-%m-%d 2>/dev/null || echo "2099-12-31")
    if [[ "$due" > "$today" && "$due" < "$future" ]] || [[ "$due" == "$future" ]]; then
        return 0
    fi
    return 1
}


# Check if a todo has open (pending) blockers
has_open_blockers() {
    local id="$1"
    if [[ ! -f "$TODO_FILE" ]]; then
        return 1
    fi

    local blockers
    blockers=$($ZQ -c "select(.id == \"$id\") | .blockers" < "$TODO_FILE" 2>/dev/null | tr -d '\n')

    if [[ -z "$blockers" ]] || [[ "$blockers" == "[]" ]] || [[ "$blockers" == "null" ]]; then
        return 1
    fi

    # Check if any blocker is still pending
    local blocker_ids
    blocker_ids=$(echo "$blockers" | $ZQ -r '.[]' 2>/dev/null)

    for bid in $blocker_ids; do
        local blocker_status
        blocker_status=$($ZQ -c "select(.id == \"$bid\") | .status" < "$TODO_FILE" 2>/dev/null | tr -d '\n"')
        if [[ "$blocker_status" == "pending" ]]; then
            return 0
        fi
    done
    return 1
}

# Get open blocker count for a todo
get_blocker_count() {
    local id="$1"
    if [[ ! -f "$TODO_FILE" ]]; then
        echo 0
        return
    fi

    local blockers
    blockers=$($ZQ -c "select(.id == \"$id\") | .blockers" < "$TODO_FILE" 2>/dev/null | tr -d '\n')

    if [[ -z "$blockers" ]] || [[ "$blockers" == "[]" ]] || [[ "$blockers" == "null" ]]; then
        echo 0
        return
    fi

    local count=0
    local blocker_ids
    blocker_ids=$(echo "$blockers" | $ZQ -r '.[]' 2>/dev/null)

    for bid in $blocker_ids; do
        local blocker_status
        blocker_status=$($ZQ -c "select(.id == \"$bid\") | .status" < "$TODO_FILE" 2>/dev/null | tr -d '\n"')
        if [[ "$blocker_status" == "pending" ]]; then
            count=$((count + 1))
        fi
    done
    echo $count
}


# Ensure todo file exists
ensure_file() {
    if [[ ! -f "$TODO_FILE" ]]; then
        touch "$TODO_FILE"
    fi
}

# Check if a todo with given ID exists
todo_exists() {
    local id="$1"
    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        return 1
    fi
    $ZQ -c "select(.id == \"$id\")" < "$TODO_FILE" 2>/dev/null | grep -q .
}

# Extract tags from text (@mentions and #hashtags)
extract_tags() {
    local text="$1"
    echo "$text" | grep -oE '(@[a-zA-Z0-9_]+|#[a-zA-Z0-9_]+)' | sort -u | \
        awk 'BEGIN{printf "["} NR>1{printf ","} {printf "\"%s\"", $0} END{printf "]"}'
}

# Update a todo by ID with jn-edit
update_todo() {
    local id="$1"
    shift
    local edits=("$@")

    local temp_file
    temp_file=$(mktemp)
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local line_id
            line_id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            if [[ "$line_id" == "$id" ]]; then
                local result="$line"
                for edit in "${edits[@]}"; do
                    result=$(echo "$result" | $JN_EDIT "$edit")
                done
                echo "$result"
            else
                echo "$line"
            fi
        fi
    done < "$TODO_FILE" > "$temp_file"
    mv "$temp_file" "$TODO_FILE"
}

# -----------------------------------------------------------------------------
# Commands
# -----------------------------------------------------------------------------

cmd_add() {
    local priority=""
    local due=""
    local parent=""
    local tags_arg=""
    local text=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--priority)
                priority="$2"
                shift 2
                ;;
            -d|--due)
                due="$2"
                shift 2
                ;;
            --parent)
                parent="$2"
                shift 2
                ;;
            -t|--tags)
                tags_arg="$2"
                shift 2
                ;;
            *)
                if [[ -z "$text" ]]; then
                    text="$1"
                else
                    text="$text $1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$text" ]]; then
        emit_error "USAGE" "Usage: todo add [-p high|med|low] [-d YYYY-MM-DD] [--parent ID] [-t tags] task"
        exit 1
    fi

    # Validate parent exists if specified (allow partial ID matching)
    if [[ -n "$parent" ]]; then
        local resolved_parent
        resolved_parent=$(resolve_id "$parent")
        if [[ -z "$resolved_parent" ]]; then
            emit_error "NOT_FOUND" "Parent todo $parent not found"
            exit 1
        fi
        parent="$resolved_parent"
    fi

    # Normalize priority
    case "$priority" in
        high|h|0) priority="high" ;;
        med|m|1|"") priority="med" ;;
        low|l|2) priority="low" ;;
        *)
            emit_error "INVALID_PRIORITY" "Invalid priority: $priority (use high, med, low)"
            exit 1
            ;;
    esac

    ensure_file

    local id
    id=$(new_xid)

    # Extract tags from text and --tags argument
    local tags
    tags=$(extract_tags "$text")
    if [[ "$tags" == "[]" ]] || [[ -z "$tags" ]]; then
        tags="[]"
    fi

    # Add tags from --tags argument (comma or space separated)
    if [[ -n "$tags_arg" ]]; then
        local extra_tags
        # Parse comma or space separated tags
        for tag in $(echo "$tags_arg" | tr ',' ' '); do
            tag="${tag# }"  # trim leading space
            tag="${tag% }"  # trim trailing space
            [[ -z "$tag" ]] && continue
            # Add @ prefix if missing
            [[ "$tag" != @* ]] && tag="@$tag"
            # Append to tags array
            if [[ "$tags" == "[]" ]]; then
                tags="[\"$tag\"]"
            else
                tags="${tags%]},\"$tag\"]"
            fi
        done
    fi

    # Build the todo JSON with XID (timestamp embedded in XID, no separate created field)
    local json
    if [[ -n "$parent" ]]; then
        json='{"id":"'"$id"'","text":"'"${text//\"/\\\"}"'","status":"pending","priority":"'"$priority"'","tags":'"$tags"',"notes":[],"blockers":[],"parent":"'"$parent"'"}'
    else
        json='{"id":"'"$id"'","text":"'"${text//\"/\\\"}"'","status":"pending","priority":"'"$priority"'","tags":'"$tags"',"notes":[],"blockers":[],"parent":null}'
    fi

    # Add due date if provided
    if [[ -n "$due" ]]; then
        json=$(echo "$json" | $JN_EDIT .due="$due")
    fi

    echo "$json" >> "$TODO_FILE"

    # Output the todo record to stdout
    echo "$json"
    # Emit event to stderr
    emit_ok "add" "\"id\":\"$id\""
}

cmd_list() {
    local filter="${1:-all}"

    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        return
    fi

    local filter_expr=""

    # Check if filtering by tag
    if [[ "$filter" == @* ]] || [[ "$filter" == \#* ]]; then
        local tag="$filter"
        filter_expr="select(.tags | join(\",\") | contains(\"$tag\"))"
    else
        case "$filter" in
            pending|p)
                filter_expr='select(.status == "pending")'
                ;;
            done|d)
                filter_expr='select(.status == "done")'
                ;;
            skipped|s)
                filter_expr='select(.status == "skipped")'
                ;;
            high|h)
                filter_expr='select(.priority == "high")'
                ;;
            *)
                filter_expr='.'
                ;;
        esac
    fi

    # Output raw NDJSON to stdout
    $ZQ -c "$filter_expr" < "$TODO_FILE" 2>/dev/null
}

cmd_ready() {
    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        return
    fi

    # Output pending todos without open blockers as NDJSON
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local id
            id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            # Skip if has open blockers
            if ! has_open_blockers "$id"; then
                echo "$line"
            fi
        fi
    done < <($ZQ -c 'select(.status == "pending")' < "$TODO_FILE" 2>/dev/null)
}

cmd_blocked() {
    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        return
    fi

    # Output pending todos with open blockers as NDJSON
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local id
            id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            # Only show if has open blockers
            if has_open_blockers "$id"; then
                echo "$line"
            fi
        fi
    done < <($ZQ -c 'select(.status == "pending")' < "$TODO_FILE" 2>/dev/null)
}

cmd_blocks() {
    local blocker_id="$1"
    local blocked_id="$2"

    if [[ -z "$blocker_id" ]] || [[ -z "$blocked_id" ]]; then
        emit_error "USAGE" "Usage: todo blocks <blocker-id> <blocked-id>"
        exit 1
    fi

    # Resolve partial IDs
    local full_blocker full_blocked
    full_blocker=$(resolve_id "$blocker_id")
    full_blocked=$(resolve_id "$blocked_id")

    if [[ -z "$full_blocker" ]]; then
        emit_error "NOT_FOUND" "Todo $blocker_id not found"
        exit 1
    fi

    if [[ -z "$full_blocked" ]]; then
        emit_error "NOT_FOUND" "Todo $blocked_id not found"
        exit 1
    fi

    if [[ "$full_blocker" == "$full_blocked" ]]; then
        emit_error "INVALID_BLOCKER" "A todo cannot block itself"
        exit 1
    fi

    backup

    # Add blocker to blocked's blockers array
    local temp_file
    temp_file=$(mktemp)
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local line_id
            line_id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            if [[ "$line_id" == "$full_blocked" ]]; then
                local result
                result=$(echo "$line" | $JN_EDIT --append .blockers "$full_blocker")
                echo "$result"
            else
                echo "$line"
            fi
        fi
    done < "$TODO_FILE" > "$temp_file"
    mv "$temp_file" "$TODO_FILE"

    emit_ok "blocks" "\"blocker\":\"$full_blocker\"" "\"blocked\":\"$full_blocked\""
}

cmd_unblock() {
    local blocker_id="$1"
    local blocked_id="$2"

    if [[ -z "$blocker_id" ]] || [[ -z "$blocked_id" ]]; then
        emit_error "USAGE" "Usage: todo unblock <blocker-id> <blocked-id>"
        exit 1
    fi

    # Resolve partial IDs
    local full_blocker full_blocked
    full_blocker=$(resolve_id "$blocker_id")
    full_blocked=$(resolve_id "$blocked_id")

    if [[ -z "$full_blocked" ]]; then
        emit_error "NOT_FOUND" "Todo $blocked_id not found"
        exit 1
    fi

    backup

    # Remove blocker from blocked's blockers array
    local temp_file
    temp_file=$(mktemp)
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local line_id
            line_id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            if [[ "$line_id" == "$full_blocked" ]]; then
                # Get current blockers, filter out the one to remove
                local blockers
                blockers=$(echo "$line" | $ZQ -c '.blockers' 2>/dev/null)
                # Build new blockers array by filtering in bash
                local new_blockers="["
                local first=true
                for blocker in $(echo "$blockers" | $ZQ -r '.[]' 2>/dev/null); do
                    if [[ "$blocker" != "$full_blocker" ]]; then
                        if [[ "$first" == "true" ]]; then
                            new_blockers="${new_blockers}\"$blocker\""
                            first=false
                        else
                            new_blockers="${new_blockers},\"$blocker\""
                        fi
                    fi
                done
                new_blockers="${new_blockers}]"
                local result
                result=$(echo "$line" | $JN_EDIT .blockers:="$new_blockers")
                echo "$result"
            else
                echo "$line"
            fi
        fi
    done < "$TODO_FILE" > "$temp_file"
    mv "$temp_file" "$TODO_FILE"

    emit_ok "unblock" "\"blocker\":\"$full_blocker\"" "\"blocked\":\"$full_blocked\""
}

cmd_tree() {
    local root_id="${1:-}"

    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        return
    fi

    # Output tree nodes as NDJSON with depth and relationship info
    output_tree_node() {
        local id="$1"
        local depth="$2"
        local parent_id="$3"

        local line
        line=$($ZQ -c "select(.id == \"$id\")" < "$TODO_FILE" 2>/dev/null)
        if [[ -z "$line" ]]; then
            return
        fi

        # Add tree metadata to the record
        if [[ -n "$parent_id" ]]; then
            echo "$line" | $JN_EDIT .tree_depth:="$depth" | $JN_EDIT .blocks="$parent_id"
        else
            echo "$line" | $JN_EDIT .tree_depth:="$depth"
        fi
    }

    # Recursively output blockers
    output_blockers() {
        local id="$1"
        local depth="$2"

        local blockers
        blockers=$($ZQ -c "select(.id == \"$id\") | .blockers" < "$TODO_FILE" 2>/dev/null)

        if [[ -z "$blockers" ]] || [[ "$blockers" == "[]" ]] || [[ "$blockers" == "null" ]]; then
            return
        fi

        local blocker_ids
        blocker_ids=$(echo "$blockers" | $ZQ -r '.[]' 2>/dev/null)

        for bid in $blocker_ids; do
            output_tree_node "$bid" "$depth" "$id"
            output_blockers "$bid" "$((depth + 1))"
        done
    }

    if [[ -n "$root_id" ]]; then
        # Resolve partial ID and show tree for specific todo
        local full_root
        full_root=$(resolve_id "$root_id")
        if [[ -z "$full_root" ]]; then
            emit_error "NOT_FOUND" "Todo $root_id not found"
            exit 1
        fi
        output_tree_node "$full_root" 0 ""
        output_blockers "$full_root" 1
    else
        # Show all todos that have blockers
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local id blockers
                id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
                blockers=$(echo "$line" | $ZQ -c '.blockers' 2>/dev/null)

                # Only show if it has blockers
                if [[ -n "$blockers" ]] && [[ "$blockers" != "[]" ]] && [[ "$blockers" != "null" ]]; then
                    output_tree_node "$id" 0 ""
                    output_blockers "$id" 1
                fi
            fi
        done < "$TODO_FILE"
    fi
}

cmd_count() {
    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        echo '{"total":0,"pending":0,"done":0,"skipped":0,"ready":0,"blocked":0,"overdue":0}'
        return
    fi

    local total pending done_count skipped
    total=$(wc -l < "$TODO_FILE" | tr -d ' ')
    pending=$($ZQ -c 'select(.status == "pending")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')
    done_count=$($ZQ -c 'select(.status == "done")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')
    skipped=$($ZQ -c 'select(.status == "skipped")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')

    local overdue=0 blocked=0 ready=0
    local today
    today=$(date +%Y-%m-%d)
    overdue=$($ZQ -c "select(.status == \"pending\") | select(.due != null) | select(.due < \"$today\")" < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')

    # Count blocked and ready
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local id
            id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            if has_open_blockers "$id"; then
                blocked=$((blocked + 1))
            else
                ready=$((ready + 1))
            fi
        fi
    done < <($ZQ -c 'select(.status == "pending")' < "$TODO_FILE" 2>/dev/null)

    echo "{\"total\":$total,\"pending\":$pending,\"done\":$done_count,\"skipped\":$skipped,\"ready\":$ready,\"blocked\":$blocked,\"overdue\":$overdue}"
}

cmd_stats() {
    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        echo '{"total":0,"pending":0,"done":0,"skipped":0,"priority":{"high":0,"med":0,"low":0},"workflow":{"ready":0,"blocked":0},"due":{"overdue":0,"soon":0,"none":0},"top_tags":[]}'
        return
    fi

    # Counts by status
    local total pending done_count skipped
    total=$(wc -l < "$TODO_FILE" | tr -d ' ')
    pending=$($ZQ -c 'select(.status == "pending")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')
    done_count=$($ZQ -c 'select(.status == "done")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')
    skipped=$($ZQ -c 'select(.status == "skipped")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')

    # Counts by priority
    local high med low
    high=$($ZQ -c 'select(.status == "pending") | select(.priority == "high")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')
    med=$($ZQ -c 'select(.status == "pending") | select(.priority == "med")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')
    low=$($ZQ -c 'select(.status == "pending") | select(.priority == "low")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')

    # Blockers
    local blocked=0 ready=0
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local id
            id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            if has_open_blockers "$id"; then
                blocked=$((blocked + 1))
            else
                ready=$((ready + 1))
            fi
        fi
    done < <($ZQ -c 'select(.status == "pending")' < "$TODO_FILE" 2>/dev/null)

    # Due dates
    local today overdue due_soon no_due
    today=$(date +%Y-%m-%d)
    local future
    future=$(date -d "+7 days" +%Y-%m-%d 2>/dev/null || date -v+7d +%Y-%m-%d 2>/dev/null || echo "2099-12-31")
    overdue=$($ZQ -c "select(.status == \"pending\") | select(.due != null) | select(.due < \"$today\")" < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')
    due_soon=$($ZQ -c "select(.status == \"pending\") | select(.due != null) | select(.due >= \"$today\") | select(.due <= \"$future\")" < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')
    no_due=$($ZQ -c 'select(.status == "pending") | select(.due == null)' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')

    # Top tags as JSON array
    local top_tags="[]"
    if [[ -f "$TODO_FILE" ]]; then
        top_tags=$($ZQ -c 'select(.status == "pending") | .tags | .[]' < "$TODO_FILE" 2>/dev/null | \
            sort | uniq -c | sort -rn | head -5 | \
            awk 'BEGIN{printf "["} NR>1{printf ","} {printf "{\"tag\":%s,\"count\":%d}", $2, $1} END{printf "]"}')
        [[ -z "$top_tags" ]] && top_tags="[]"
    fi

    echo "{\"total\":$total,\"pending\":$pending,\"done\":$done_count,\"skipped\":$skipped,\"priority\":{\"high\":$high,\"med\":$med,\"low\":$low},\"workflow\":{\"ready\":$ready,\"blocked\":$blocked},\"due\":{\"overdue\":$overdue,\"soon\":$due_soon,\"none\":$no_due},\"top_tags\":$top_tags}"
}

cmd_search() {
    local term="$1"
    if [[ -z "$term" ]]; then
        emit_error "USAGE" "Usage: todo search <term>"
        exit 1
    fi

    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        return
    fi

    # Output matching records as NDJSON
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local text
            text=$(echo "$line" | $ZQ -r '.text' 2>/dev/null)
            if echo "$text" | grep -qi "$term"; then
                echo "$line"
            fi
        fi
    done < "$TODO_FILE"
}

cmd_done() {
    local id="$1"
    if [[ -z "$id" ]]; then
        emit_error "USAGE" "Usage: todo done <id>"
        exit 1
    fi

    # Resolve partial ID
    local full_id
    full_id=$(resolve_id "$id")
    if [[ -z "$full_id" ]]; then
        emit_error "NOT_FOUND" "Todo $id not found"
        exit 1
    fi

    backup
    update_todo "$full_id" ".status=done"
    emit_ok "done" "\"id\":\"$full_id\""
}

cmd_skip() {
    local id="$1"
    if [[ -z "$id" ]]; then
        emit_error "USAGE" "Usage: todo skip <id>"
        exit 1
    fi

    # Resolve partial ID
    local full_id
    full_id=$(resolve_id "$id")
    if [[ -z "$full_id" ]]; then
        emit_error "NOT_FOUND" "Todo $id not found"
        exit 1
    fi

    backup
    update_todo "$full_id" ".status=skipped"
    emit_ok "skip" "\"id\":\"$full_id\""
}

cmd_reopen() {
    local id="$1"
    if [[ -z "$id" ]]; then
        emit_error "USAGE" "Usage: todo reopen <id>"
        exit 1
    fi

    # Resolve partial ID
    local full_id
    full_id=$(resolve_id "$id")
    if [[ -z "$full_id" ]]; then
        emit_error "NOT_FOUND" "Todo $id not found"
        exit 1
    fi

    backup
    update_todo "$full_id" ".status=pending"
    emit_ok "reopen" "\"id\":\"$full_id\""
}

cmd_bump() {
    local id="$1"
    if [[ -z "$id" ]]; then
        emit_error "USAGE" "Usage: todo bump <id> - Cycles priority: low â†’ med â†’ high â†’ low"
        exit 1
    fi

    # Resolve partial ID
    local full_id
    full_id=$(resolve_id "$id")
    if [[ -z "$full_id" ]]; then
        emit_error "NOT_FOUND" "Todo $id not found"
        exit 1
    fi

    local current_priority
    current_priority=$($ZQ -c "select(.id == \"$full_id\") | .priority" < "$TODO_FILE" 2>/dev/null | tr -d '\n"')

    local new_priority
    case "$current_priority" in
        low) new_priority="med" ;;
        med) new_priority="high" ;;
        high) new_priority="low" ;;
        *) new_priority="med" ;;
    esac

    backup
    update_todo "$full_id" ".priority=$new_priority"
    emit_ok "bump" "\"id\":\"$full_id\"" "\"from\":\"$current_priority\"" "\"to\":\"$new_priority\""
}

cmd_retag() {
    local old_tag="$1"
    local new_tag="$2"

    if [[ -z "$old_tag" ]] || [[ -z "$new_tag" ]]; then
        emit_error "USAGE" "Usage: todo retag <old-tag> <new-tag>"
        exit 1
    fi

    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        emit_ok "retag" "\"from\":\"$old_tag\"" "\"to\":\"$new_tag\"" "\"count\":0"
        return
    fi

    backup

    local count=0
    local temp_file
    temp_file=$(mktemp)

    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local tags
            tags=$(echo "$line" | $ZQ -c '.tags' 2>/dev/null)

            if echo "$tags" | grep -q "\"$old_tag\""; then
                # Replace old tag with new tag using two-pass approach
                # (zq doesn't support conditionals in array comprehensions)
                local new_tags
                new_tags=$(echo "$tags" | $ZQ -c ".[] | if . == \"$old_tag\" then \"$new_tag\" else . end" 2>/dev/null | $ZQ -s -c '.' 2>/dev/null)
                local result
                result=$(echo "$line" | $JN_EDIT .tags:="$new_tags")
                echo "$result"
                count=$((count + 1))
            else
                echo "$line"
            fi
        fi
    done < "$TODO_FILE" > "$temp_file"
    mv "$temp_file" "$TODO_FILE"

    emit_ok "retag" "\"from\":\"$old_tag\"" "\"to\":\"$new_tag\"" "\"count\":$count"
}

cmd_edit() {
    local id="$1"
    shift
    local new_text="$*"

    if [[ -z "$id" ]] || [[ -z "$new_text" ]]; then
        emit_error "USAGE" "Usage: todo edit <id> \"new text\""
        exit 1
    fi

    # Resolve partial ID
    local full_id
    full_id=$(resolve_id "$id")
    if [[ -z "$full_id" ]]; then
        emit_error "NOT_FOUND" "Todo $id not found"
        exit 1
    fi

    local tags
    tags=$(extract_tags "$new_text")

    backup
    local temp_file
    temp_file=$(mktemp)
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local line_id
            line_id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            if [[ "$line_id" == "$full_id" ]]; then
                local result
                result=$(echo "$line" | $JN_EDIT .text="$new_text")
                result=$(echo "$result" | $JN_EDIT .tags:="$tags")
                echo "$result"
            else
                echo "$line"
            fi
        fi
    done < "$TODO_FILE" > "$temp_file"
    mv "$temp_file" "$TODO_FILE"

    emit_ok "edit" "\"id\":\"$full_id\""
}

cmd_note() {
    local id="$1"
    shift
    local note_text="$*"

    if [[ -z "$id" ]]; then
        emit_error "USAGE" "Usage: todo note <id> [\"note text\"]"
        exit 1
    fi

    # Resolve partial ID
    local full_id
    full_id=$(resolve_id "$id")
    if [[ -z "$full_id" ]]; then
        emit_error "NOT_FOUND" "Todo $id not found"
        exit 1
    fi

    if [[ -z "$note_text" ]]; then
        # View notes - output as JSON to stdout
        local notes
        notes=$($ZQ -c "select(.id == \"$full_id\") | .notes" < "$TODO_FILE" 2>/dev/null)
        echo "{\"id\":\"$full_id\",\"notes\":$notes}"
        return
    fi

    backup

    local temp_file
    temp_file=$(mktemp)
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local line_id
            line_id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
            if [[ "$line_id" == "$full_id" ]]; then
                local result
                result=$(echo "$line" | $JN_EDIT --append .notes "$note_text")
                echo "$result"
            else
                echo "$line"
            fi
        fi
    done < "$TODO_FILE" > "$temp_file"
    mv "$temp_file" "$TODO_FILE"

    emit_ok "note" "\"id\":\"$full_id\""
}

cmd_tag() {
    local id="$1"
    if [[ -z "$id" ]]; then
        emit_error "USAGE" "Usage: todo tag <id>"
        exit 1
    fi

    # Resolve partial ID
    local full_id
    full_id=$(resolve_id "$id")
    if [[ -z "$full_id" ]]; then
        emit_error "NOT_FOUND" "Todo $id not found"
        exit 1
    fi

    local tags
    tags=$($ZQ -c "select(.id == \"$full_id\") | .tags" < "$TODO_FILE" 2>/dev/null)

    # Output as JSON to stdout
    echo "{\"id\":\"$full_id\",\"tags\":$tags}"
}

cmd_due() {
    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        return
    fi

    local today
    today=$(date +%Y-%m-%d)
    local future
    future=$(date -d "+7 days" +%Y-%m-%d 2>/dev/null || date -v+7d +%Y-%m-%d 2>/dev/null || echo "2099-12-31")

    # Output all pending todos with due dates, adding a "due_status" field
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local due
            due=$(echo "$line" | $ZQ -r '.due' 2>/dev/null | tr -d '\n')
            local due_status="upcoming"
            if [[ "$due" < "$today" ]]; then
                due_status="overdue"
            elif [[ "$due" < "$future" ]] || [[ "$due" == "$future" ]]; then
                due_status="soon"
            fi
            echo "$line" | $JN_EDIT .due_status="$due_status"
        fi
    done < <($ZQ -c "select(.status == \"pending\") | select(.due != null)" < "$TODO_FILE" 2>/dev/null)
}

cmd_rm() {
    local id="$1"
    if [[ -z "$id" ]]; then
        emit_error "USAGE" "Usage: todo rm <id>"
        exit 1
    fi

    # Resolve partial ID
    local full_id
    full_id=$(resolve_id "$id")
    if [[ -z "$full_id" ]]; then
        emit_error "NOT_FOUND" "Todo $id not found"
        exit 1
    fi

    backup

    local temp_file
    temp_file=$(mktemp)
    $ZQ -c "select(.id != \"$full_id\")" < "$TODO_FILE" 2>/dev/null > "$temp_file"
    mv "$temp_file" "$TODO_FILE"

    emit_ok "rm" "\"id\":\"$full_id\""
}

cmd_clear() {
    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        emit_ok "clear" "\"cleared\":0"
        return
    fi

    # Count how many will be cleared
    local cleared
    cleared=$($ZQ -c 'select(.status != "pending")' < "$TODO_FILE" 2>/dev/null | wc -l | tr -d ' ')

    backup

    local temp_file
    temp_file=$(mktemp)
    $ZQ -c 'select(.status == "pending")' < "$TODO_FILE" 2>/dev/null > "$temp_file"
    mv "$temp_file" "$TODO_FILE"

    emit_ok "clear" "\"cleared\":$cleared"
}

cmd_undo() {
    if [[ ! -f "$BACKUP_FILE" ]]; then
        emit_error "NO_BACKUP" "No backup available to restore"
        exit 1
    fi

    cp "$BACKUP_FILE" "$TODO_FILE"
    emit_ok "undo"
}

cmd_export() {
    local format="${1:-md}"

    if [[ ! -f "$TODO_FILE" ]] || [[ ! -s "$TODO_FILE" ]]; then
        return
    fi

    case "$format" in
        md|markdown)
            echo "# Todo List"
            echo ""
            echo "## Pending"
            $ZQ -c 'select(.status == "pending")' < "$TODO_FILE" 2>/dev/null | while read -r line; do
                local text priority due
                text=$(echo "$line" | $ZQ -r '.text' 2>/dev/null)
                priority=$(echo "$line" | $ZQ -r '.priority' 2>/dev/null)
                due=$(echo "$line" | $ZQ -r '.due' 2>/dev/null)
                local pri_mark=""
                [[ "$priority" == "high" ]] && pri_mark=" ðŸ”´"
                [[ "$priority" == "low" ]] && pri_mark=" ðŸŸ¢"
                local due_mark=""
                [[ -n "$due" && "$due" != "null" ]] && due_mark=" (due: $due)"
                echo "- [ ] $text$pri_mark$due_mark"
            done
            echo ""
            echo "## Done"
            $ZQ -c 'select(.status == "done")' < "$TODO_FILE" 2>/dev/null | while read -r line; do
                local text
                text=$(echo "$line" | $ZQ -r '.text' 2>/dev/null)
                echo "- [x] $text"
            done
            echo ""
            echo "## Skipped"
            $ZQ -c 'select(.status == "skipped")' < "$TODO_FILE" 2>/dev/null | while read -r line; do
                local text
                text=$(echo "$line" | $ZQ -r '.text' 2>/dev/null)
                echo "- [~] $text"
            done
            ;;
        csv)
            echo "id,text,status,priority,due,tags,blockers,notes_count,parent"
            while read -r line; do
                local id text status priority due tags blockers notes_count parent
                id=$(echo "$line" | $ZQ -r '.id' 2>/dev/null | tr -d '\n')
                text=$(echo "$line" | $ZQ -r '.text' 2>/dev/null | tr -d '\n')
                status=$(echo "$line" | $ZQ -r '.status' 2>/dev/null | tr -d '\n')
                priority=$(echo "$line" | $ZQ -r '.priority' 2>/dev/null | tr -d '\n')
                due=$(echo "$line" | $ZQ -r '.due' 2>/dev/null | tr -d '\n')
                tags=$(echo "$line" | $ZQ -r '.tags | join(";")' 2>/dev/null | tr -d '\n')
                blockers=$(echo "$line" | $ZQ -r '.blockers | join(";")' 2>/dev/null | tr -d '\n')
                notes_count=$(echo "$line" | $ZQ -c '.notes | length' 2>/dev/null | tr -d '\n')
                parent=$(echo "$line" | $ZQ -r '.parent' 2>/dev/null | tr -d '\n')
                text="${text//\"/\"\"}"
                echo "$id,\"$text\",$status,$priority,$due,\"$tags\",\"$blockers\",$notes_count,$parent"
            done < "$TODO_FILE"
            ;;
        *)
            emit_error "INVALID_FORMAT" "Unknown format: $format (use md or csv)"
            exit 1
            ;;
    esac
}

cmd_help() {
    cat << 'EOF'
todo - A feature-rich todo CLI powered by jn (BEADS-inspired)

IDs are XIDs (20-char, time-sortable). Use partial prefixes like "cuvs4" to match.

BASIC COMMANDS:
  todo                              List all todos
  todo add "task"                   Add a new todo
  todo add -p high "urgent task"    Add with priority (high/med/low)
  todo add -d 2024-12-25 "task"     Add with due date
  todo add --parent cuvs4 "subtask" Add as subtask
  todo done <id>                    Mark todo as complete
  todo skip <id>                    Mark todo as skipped
  todo reopen <id>                  Reopen a completed/skipped todo
  todo edit <id> "new text"         Edit todo text
  todo rm <id>                      Remove a todo

BLOCKERS & DEPENDENCIES (BEADS-inspired):
  todo blocks <a> <b>               Task A blocks task B
  todo unblock <a> <b>              Remove blocker relationship
  todo ready                        Show tasks with no blockers (actionable!)
  todo blocked                      Show tasks waiting on others
  todo tree [id]                    Show dependency tree

ORGANIZATION:
  todo note <id> "note"             Add note to a todo
  todo note <id>                    View notes on a todo
  todo tag <id>                     Show tags on a todo
  todo bump <id>                    Cycle priority: lowâ†’medâ†’highâ†’low
  todo retag <old> <new>            Rename tag across all todos
  todo list [pending|done|skipped]  Filter by status
  todo list @mention                Filter by @mention tag
  todo list #hashtag                Filter by #hashtag

VIEWS & REPORTS:
  todo count                        Show counts by status
  todo stats                        Full statistics dashboard
  todo search <term>                Search todos by text
  todo due                          Show overdue and upcoming todos
  todo export [md|csv]              Export todos

MAINTENANCE:
  todo clear                        Remove completed/skipped todos
  todo undo                         Restore from backup

PRIORITY LEVELS:
  high (!!!)  - Urgent/blocking tasks    [red]
  med  (!!)   - Normal priority          [yellow] (default)
  low  (!)    - Nice-to-have tasks       [dim]

STATUS ICONS:
  â—‹  Pending (ready)
  âŠ—  Pending (blocked)
  âœ“  Done
  âŠ˜  Skipped

EXAMPLES:
  todo add "Fix production bug" -p high
  todo add --parent cuvs4 "Write tests"  # Use partial XID prefix
  todo blocks abc12 def34             # Task abc12 blocks def34
  todo ready                          # What can I work on now?
  todo done abc12                     # Complete blocker (partial ID)
  todo cuvs4                          # Quick: mark cuvs4... as done
  todo stats                          # Full dashboard

Data stored in .todo.jsonl (NDJSON format).
IDs are XIDs with embedded timestamps - use xid_time() in ZQ to extract.
Powered by jn-edit and zq.
EOF
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

case "${1:-list}" in
    add|a)
        shift
        cmd_add "$@"
        ;;
    list|ls|l)
        shift 2>/dev/null || true
        cmd_list "$@"
        ;;
    ready|r)
        cmd_ready
        ;;
    blocked)
        cmd_blocked
        ;;
    blocks|block)
        shift
        cmd_blocks "$@"
        ;;
    unblock)
        shift
        cmd_unblock "$@"
        ;;
    tree)
        shift
        cmd_tree "$@"
        ;;
    done|complete|c)
        shift
        cmd_done "$@"
        ;;
    skip)
        shift
        cmd_skip "$@"
        ;;
    reopen)
        shift
        cmd_reopen "$@"
        ;;
    bump)
        shift
        cmd_bump "$@"
        ;;
    retag)
        shift
        cmd_retag "$@"
        ;;
    edit|e)
        shift
        cmd_edit "$@"
        ;;
    note|n)
        shift
        cmd_note "$@"
        ;;
    tag|t)
        shift
        cmd_tag "$@"
        ;;
    rm|remove|delete)
        shift
        cmd_rm "$@"
        ;;
    clear)
        cmd_clear
        ;;
    count)
        cmd_count
        ;;
    stats)
        cmd_stats
        ;;
    search)
        shift
        cmd_search "$@"
        ;;
    due)
        cmd_due
        ;;
    export)
        shift
        cmd_export "$@"
        ;;
    undo)
        cmd_undo
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        # If arg looks like an XID (base32: 0-9a-v) or partial ID, try to mark as done
        if [[ "$1" =~ ^[0-9a-v]+$ ]]; then
            cmd_done "$1"
        # If arg looks like a tag, list by tag
        elif [[ "$1" == @* ]] || [[ "$1" == \#* ]]; then
            cmd_list "$1"
        else
            emit_error "UNKNOWN_COMMAND" "Unknown command: $1. Run 'todo help' for usage."
            exit 1
        fi
        ;;
esac
